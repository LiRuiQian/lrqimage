# 			JUC学习笔记



## 1、线程和进程

- 一个进程可以包含多个线程

- Java默认有两个线程：GC、main

- Java不可以开启线程，底层将线程加入线程组，调用的是本地方法native

  ```java
  public synchronized void start() {
          group.add(this);//将线程添加到线程组
  
          boolean started = false;
          try {
              start0();
              started = true;
          } finally {
              try {
                  if (!started) {
                      group.threadStartFailed(this);
                  }
              } catch (Throwable ignore) {
              }
          }
      }
   private native void start0();//本地方法
  ```



> 并发、并行

- 并发：多线程操作一个资源，CPU一核，快速交替
- 并行：多个人一起行走

```java
 @Test
      public void test(){
          //获取CPU核数
          //CPU密集型，IO密集型
          System.out.println(Runtime.getRuntime().availableProcessors());
      }
```



  并发编程的本质：充分利用CPU的资源



> 线程状态



```java
public enum State {

    	//新生
        NEW,
    
    	//运行
        RUNNABLE,

    	//阻塞
        BLOCKED,

    	//等待
        WAITING,

    	//超时等待
        TIMED_WAITING,

    	//终止
        TERMINATED;
    }
```

------



> sleep/wait区别 

**1、来自不同的类**

wait => Object

sleep => Thread

**2、关于锁的释放**

wait会释放锁，sleep不会释放锁

**3、使用范围不同**

wait必须在同步代码块中使用

sleep可以在任何地方使用

**4、是否需要捕获异常**

wait不需要捕获异常

sleep需要捕获异常

----

## 2、Lock锁



> Lock接口

![image-20210319102017970](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319102017970.png)



![image-20210319102206904](https://i.loli.net/2021/04/20/X4sQtFo2UkwTrix.png)

```java
 public ReentrantLock() {
        sync = new NonfairSync(); //默认非公平锁
    }

    public ReentrantLock(boolean fair) { //方法重构   通过修改fair（true）可以更改为公平锁
        sync = fair ? new FairSync() : new NonfairSync();
    }
```



> hronized 和 Lock 区别

1. Synchronized 内置的Java关键字，Lock是一个Java类
2. Synchronized 无法判断获取锁的状态，Lock可以判断是否获取到了锁
3. Synchronized 会自动释放锁，Lock必须手动释放锁
4. Synchronized 线程获得锁其他线程会一直等待，Lock锁不会一直等待 可以通过tryLock尝试获取锁
5. Synchronized 可重入锁，不可以中断，非公平；Lock可重入锁，可以判断锁，非公平（可以自己设置）
6. Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码



---

## 3、生产者和消费者问题

> Condition 精准的通知和唤醒线程
>

```java
package com.lrq.demo01;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SaleTicketDemo01 {
    public static void main(String[] args) {
        data data = new data();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printA();
            }
        },"A").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printB();
            }
        },"B").start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printC();
            }
        },"C").start();

    }
}

class data{
    Lock lock = new ReentrantLock();
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Condition condition3 = lock.newCondition();
    int number = 1;
    public void printA(){
        lock.lock();
        try {
            while (number != 1){
                condition1.await();
            }
            number = 2;
            System.out.println(Thread.currentThread().getName()+"=>AAAAAA");
            condition2.signal();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void printB(){
        lock.lock();
        try {
            while (number != 2){
                condition2.await();
            }
            number = 3;
            System.out.println(Thread.currentThread().getName()+"=>BBBBBB");
            condition3.signal();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void printC(){
        lock.lock();
        try {
            while (number != 3){
                condition3.await();
            }
            number = 1;
            System.out.println(Thread.currentThread().getName()+"=>CCCCC");
            condition1.signal();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
```



## 4、8锁现象

> 如何判断锁的是谁



```java
package com.lrq.lock8;

import java.util.concurrent.TimeUnit;

//8锁现象
public class Test01 {
    public static void main(String[] args) {
        phone phone = new phone();
        new Thread(()->{
            phone.sendSms();
        },"A").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(()->{
            phone.call();
        },"B").start();
    }

}

class phone{
    public synchronized void sendSms(){
        System.out.println("发短信");
    }

    public synchronized void call(){
        System.out.println("打电话");
    }
}
```



----





```java
package com.lrq.lock8;

import java.util.concurrent.TimeUnit;

public class Tets02 {
    public static void main(String[] args) {
        phone2 phone = new phone2();
        new Thread(()->{
            phone.sendSms();
        },"A").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(()->{
            phone.call();
        },"B").start();
    }

}

class phone2{
    public static synchronized void sendSms(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call(){
        System.out.println("打电话");
    }
}

```



> 小结

new this 具体的一个对象

static Class 唯一的类模板

执行顺序是按锁的持有对象来判断的 ，上面的例子中锁的是同一对象，所以执行顺序不会变

一个对象只能持有一个锁



## 5、集合类不安全

> List 不安全

```java
package com.lrq.unsafe;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * java.util.ConcurrentModificationException 并发修改异常
 */
public class ListTest {
    public static void main(String[] args) {
        //并发下ArrayList，不安全
//        List<String> list = new ArrayList<>();
        /**
         *  解决方案
         *  List<String> list = new Vector<>();
         *  List<String> list = Collections.synchronizedList(new ArrayList<>());
         *  List<String> list = new CopyOnWriteArrayList<>();
         */
        // 写入时复制 COW    计算机程序设计领域的一种优化策略
        // 多线程调用的时候，List，读取的时候，固定的，写入（覆盖）
        // 在写入的时候避免覆盖，造成数据问题
        // CopyOnWriteArrayList（使用lock锁）比Vector（使用synchronized）效率高
        List<String> list = new CopyOnWriteArrayList<>();

        for (int i = 0; i < 50; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```



----



> Set 不安全

```java
package com.lrq.unsafe;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

//java.util.ConcurrentModificationException 并发修改异常
public class SetTest {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
//        Set<String> set = Collections.synchronizedSet(new HashSet<>());
//        Set<String> set = new CopyOnWriteArraySet<>();
        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                set.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(set);
            },String.valueOf(i)).start();
            
        }
    }

}
```

hashSet底层是什么？

```java
  public HashSet() {
        map = new HashMap<>();
    }
  //add set 本质就是 map key是无法重复的
  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
  private static final Object PRESENT = new Object();//值是不变的(常量)
```



---



> map 不安全

```java
package com.lrq.unsafe;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

//java.util.ConcurrentModificationException //并发修改异常
public class MapTest {
    public static void main(String[] args) {
//        Map<String, String> map = new HashMap<>();
        Map<String, String> map = new ConcurrentHashMap<>();
        // 加载因子，初始容量
        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
}
```

----



## 6、Callable

![image-20210319220452332](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319220452332.png)

1、可以有返回值

2、可以抛出异常

3、方法不同，call()

> 代码测试

![image-20210319221622321](https://cdn.jsdelivr.net/gh/Lrqian/lrqimage/img/20210420231721.png)



![image-20210319221559961](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319221559961.png)

```java
package com.lrq.callable;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
//        new Thread(new FutureTask<>()).start();
        new Thread().start();
        MyThread myThread = new MyThread();
        FutureTask<Integer> integerFutureTask = new FutureTask<>(myThread);//适配类
        new Thread(integerFutureTask, "A").start();
        new Thread(integerFutureTask, "B").start();//结果会被缓存，效率高
        Integer o = integerFutureTask.get();//获取返回结果  这个方法可能产生阻塞！把他放在最后
        //或者使用异步通信处理
        System.out.println(o);
    }
}
class MyThread implements Callable<Integer> {

    @Override
    public Integer call(){
        System.out.println("call()");
        return 6789;
    }
}
```

细节：

1. 有缓存
2. 如果可能需要等待，会阻塞

---

## 7、常用的辅助类

### 7.1 CountDownLatch

```java
package com.lrq.add;

import java.util.concurrent.CountDownLatch;

// 计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        //总数是6
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 0; i < 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"Go out");
                countDownLatch.countDown();//数量-1
            },String.valueOf(i)).start();
        }
        countDownLatch.await();// 等待计数器归零，然后再向下执行
        
        System.out.println("Close Door!");
    }
}
```

原理：

`countDownLatch.countDown();`//数量-1

`countDownLatch.await();`// 等待计数器归零，然后再向下执行

每次有线程调用countDown()数量-1，假设计数器变为0，countDownLatch.await()就会被唤醒，继续执行。

----

### 7.2 CyclicBarrier



![image-20210319224049489](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319224049489.png)

```java
package com.lrq.add;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
            System.out.println("完成");
        });
        for (int i = 0; i <= 7; i++) {
            final int temp = i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "=>"+temp);
                try {
                    cyclicBarrier.await()
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

---

### 7.3 Semaphore

Semaphore:信号量

![image-20210319225354821](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319225354821.png)

```java
package com.lrq.add;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class SemaphoreDemo {
    public static void main(String[] args) {
        //线程数量
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                
                try {
                    semaphore.acquire();//acquire() 获取
                    System.out.println(Thread.currentThread().getName()+"抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName()+"离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    //release() 释放
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

原理：

`semaphore.acquire();`获取，假如如果已经满了，等待，被释放为止！

`semaphore.release();`释放，会将当前的信号量释放 -1，然后唤醒等待线程！

作用：多个共享资源互斥的使用；并发限流，控制最大线程数

---

## 8、读写锁 

ReadWriteLock：读可以被多个线程同时读，写的时候只能有一个线程去写

![image-20210328215133816](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328215133816.png)



```java
package com.lrq.rw;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * ReadWriteLock
 * 读-读 可以共存
 * 读-写 不能共存
 * 写-写 不能共存
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCacheLock myCache = new MyCacheLock();
        for (int i = 1; i <= 5; i++) {
            final int temp = i;
            new Thread(()->{
                myCache.put(temp+"",temp+"");
            },String.valueOf(i)).start();
        }

        for (int i = 1; i <= 5; i++) {
            final int temp = i;
            new Thread(()->{
                myCache.get(temp+"");
            },String.valueOf(i)).start();
        }
    }
}
//加锁
class MyCacheLock{
    private volatile Map<String, Object> map = new HashMap<>();
    //读写锁，更加细细粒度的控制
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //存，写入的时候，只有一个线程操作
    public void put(String key,Object value){
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"写入"+key);
            map.put(key,value);
            System.out.println(Thread.currentThread().getName()+"写入完成");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    public void get(String key){
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"读取"+key);
            Object value = map.get(key);
            System.out.println(Thread.currentThread().getName()+"读取 完成");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }

    }
}

/**
 * 自定义缓存
 */
class MyCache{
    private volatile Map<String, Object> map = new HashMap<>();
	//写入
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"写入"+key);
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"写入完成");
    }
	//读取
    public void get(String key){
        System.out.println(Thread.currentThread().getName()+"读取"+key);
        Object value = map.get(key);
        System.out.println(Thread.currentThread().getName()+"读取 完成");
    }
}
```

---

## 9、阻塞队列

![image-20210320144533807](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210320144533807.png)

多线程并发编程，线程池会使用阻塞队列

**四组API**

> | 方式       | 抛出异常 | 有返回值，不抛出异常 | 阻塞等待 | 超时等待  |
> | ---------- | -------- | -------------------- | -------- | --------- |
> | 添加       | add      | offer()              | put()    | offer(,,) |
> | 移除       | remove   | poll()               | take()   | poll(,)   |
> | 检测队列首 | element  | peek                 |          |           |
>

```java
package com.lrq.bq;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * 阻塞队列
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        test4();
    }

    /**
     * 抛出异常
     */
    private static void test1(){
        //设置队列大小
        BlockingQueue blockingQueue = new ArrayBlockingQueue(3);
        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));
//        IllegalStateException: Queue full 抛出异常
//        System.out.println(blockingQueue.add("d"));
        System.out.println(blockingQueue.element());//
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());

//        java.util.NoSuchElementException 抛出异常
//        System.out.println(blockingQueue.remove());
    }

    /**
     * 不抛出异常
     */
    private static void test2(){
        //设置队列大小
        BlockingQueue blockingQueue = new ArrayBlockingQueue(3);

        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
//        System.out.println(blockingQueue.offer("d"));//false 不抛出异常
        System.out.println(blockingQueue.peek());//检测队首元素
        System.out.println("=============");

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
//        System.out.println(blockingQueue.poll());//不抛出异常
    }

    /**
     * 阻塞等待
     */
    private static void test3() throws InterruptedException {
        //设置队列大小
        BlockingQueue blockingQueue = new ArrayBlockingQueue(3);
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
//        blockingQueue.put("d");//阻塞，一直等待
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());//阻塞，一直等待

    }

    /**
     * 阻塞等待（等待延时）
     */
    private static void test4() throws InterruptedException {
        //设置队列大小
        BlockingQueue blockingQueue = new ArrayBlockingQueue(3);

        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        System.out.println(blockingQueue.offer("d",2, TimeUnit.SECONDS));//等待超时就退出

        System.out.println("==============");
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll(2,TimeUnit.SECONDS));//等待超时就退出

    }
}

```



----



> SynchronousQueue 同步队列

```java
package com.lrq.bq;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * 同步队列
 * SynchronousQueue不存储元素
 * put了一个元素，必须从队列中take取出，否则无法put进元素
 */
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();//同步队列

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"put 1");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName()+"put 2");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName()+"put 3");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T1").start();

        new Thread(()->{
            new Thread(()->{
                try {
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"=>"+blockingQueue.take());
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"=>"+blockingQueue.take());
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"=>"+blockingQueue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        },"T2").start();
    }
}
```

---

## 10、线程池

线程池：三大方法、七大参数、四种拒绝策略

> 池化技术

程序的运行，本质：占用系统的资源，优化资源的使用！=>池化技术

池化技术：事先准备好资源，直接从池里去取，用完之后归还到池中

**线程池的好处**

1. 降低资源消耗
2. 提高响应速度
3. 方便线程管理

**`线程复用、可以控制最大线程并发量、管理线程`**



> 线程池：三大方法

![image-20210321150517809](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321150517809.png)

```java
package com.lrq.pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Executors 工具类：3大方法
 */
public class Demo01 {
    public static void main(String[] args) {
//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程池
//        ExecutorService threadPool =Executors.newFixedThreadPool(5);//固定线程池
        ExecutorService threadPool =Executors.newCachedThreadPool();//可伸缩扩展线程池

        try {
            for (int i = 0; i < 100; i++) {
                //线程池创建线程
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();//关闭线程池
        }
    }
}
```

---

> 7大参数

源码分析

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,//约等于21亿
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
}

//本质ThreadPoolExecutor()
public ThreadPoolExecutor(int corePoolSize,//核心线程池大小
                          int maximumPoolSize,//最大线程池大小
                          long keepAliveTime,//设置超时时间
                          TimeUnit unit,//超时单位
                          BlockingQueue<Runnable> workQueue,//阻塞队列
                          ThreadFactory threadFactory,//线程工厂：创建线程的
                          RejectedExecutionHandler handler//拒绝策略) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
        null :
    AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

---

> 4中拒绝策略

![image-20210321192342935](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321192342935.png)

```java
package com.lrq.pool;

import java.util.concurrent.*;

/**
 * new ThreadPoolExecutor.AbortPolicy()// 最大承载满了，继续有任务进来，不处理该任务，抛出异常
 * new ThreadPoolExecutor.CallerRunsPolicy()// 哪来的去哪里
 * new ThreadPoolExecutor.DiscardPolicy()// 队列满了，丢掉任务，不会抛出异常
 * new ThreadPoolExecutor.DiscardOldestPolicy()// 队列满了，尝试和最早的竞争，不会抛出异常
 */
public class Demo01 {
    public static void main(String[] args) {
        //自定义线程池
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy()// 队列满了，尝试和最早的竞争，不会抛出异常
                );

        try {
            // 最大承载：Deque+Max
            // 超出最大承载 抛出异常：RejectedExecutionException
            for (int i = 1; i <= 9; i++) {
                //线程池创建线程
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();//关闭线程池
        }
    }
}
```

---



> 小结和拓展

线程池的最大的大小如何设置

IO密集型，CPU密集型（调优）

1. CPU 密集型，几核，就是几，可以保持CPU的效率最高

```java
ExecutorService threadPool = new ThreadPoolExecutor(
        2,
        Runtime.getRuntime().availableProcessors(),//获取CPU核数
        3,
        TimeUnit.SECONDS,
        new LinkedBlockingDeque<>(3),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.DiscardOldestPolicy()// 队列满了，尝试和最早的竞争，不会抛出异常
        );
```

2. IO 密集型，判断程序中十分耗IO的线程，IO十分占用资源。设置线程数大于程序中IO线程任务的2-3倍



---



## 11、四大函数式接口

> 函数式接口：只有一个方法的接口

```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
//有非常多的FunctionalInterface
//简化编程模型，底层框架大量运用
//foreach(消费者类的函数式接口)
```

代码测试：

> Function 函数式接口

```java
package com.lrq.function;

import java.util.function.Function;

/**
 * Function 函数型接口，有一个输入参数，有一个输出
 * 只要是 函数型接口 就可以用 lambda表达式简化
 */
public class Demo01 {
    public static void main(String[] args) {
//        Function function = new Function<String,String>() {
//            @Override
//            public String apply(String str) {
//                return str;
//            }
//        };
        Function function = (str)->{return str;};
        System.out.println(function.apply("abc"));
    }
}
```

---



> 断定型接口：有一个输入参数，返回值只能是布尔型

```java
package com.lrq.function;

import java.util.function.Predicate;

/**
 * 断定型接口：有一个输入参数，返回值只能是布尔型
 */
public class Demo02 {
    public static void main(String[] args) {
        //判断字符串是否为空
//        Predicate predicate = new Predicate<String>() {
//            @Override
//            public boolean test(String str) {
//                return str.isEmpty();
//            }
//        };
        Predicate<String> predicate = (str) ->{
            return str.isEmpty();
        };
        System.out.println(predicate.test(""));
    }
}
```

---



> Consumer 消费型接口

```java
package com.lrq.function;

import java.util.function.Consumer;

/**
 * Consumer 消费型接口，只有输入，没有返回值
 */
public class Demo03 {
    public static void main(String[] args) {
//        Consumer consumer = new Consumer<String>() {
//            @Override
//            public void accept(String str) {
//                System.out.println(str);
//            }
//        };
        Consumer consumer = (str)->{System.out.println(str);};
        consumer.accept("abc");
    }
}
```

---



> Supplier 供给型接口

```java
package com.lrq.function;

import java.util.function.Supplier;

/**
 * Supplier 供给型接口 没有参数，只有返回值
 */
public class Demo04 {
    public static void main(String[] args) {
//        Supplier supplier = new Supplier<String>() {
//            @Override
//            public String get() {
//                return "1024";
//            }
//        };
        Supplier supplier = ()->{return "1024";};
        System.out.println(supplier.get());
    }
}
```

---



## 12、Stream流式计算

> 什么是Stream流式计算

大数据：存储 + 计算

集合，MySQL 本质就是存储数据

计算都应该交给流来操作

![image-20210321215329067](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210321215329067.png)





```java
package com.lrq.stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 1.ID 必须是偶数
 * 2.年龄必须大约23
 * 3.用户名大写
 * 4.用户名倒序
 * 5.只输入一个用户
 */
public class Test {
    public static void main(String[] args) {
        User u1 = new User(1, "a", 21);
        User u2 = new User(2, "b", 22);
        User u3 = new User(3, "c", 23);
        User u4 = new User(4, "d", 24);
        User u5 = new User(6, "e", 25);
        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);
        list.stream().filter(u ->{return u.getId()%2==0;})
                     .filter(u ->{return u.getAge()> 23;})
                     .map(u -> {return u.getName().toUpperCase();})
                     .sorted((uu1,uu2) -> {return uu2.compareTo(uu1);})
                     .limit(1)
                     .forEach(System.out::println);
    }
}
```



## 13、ForkJoin

> 什么是ForkJoin

JDK1.7出现，并行执行任务，提高效率，大数据量使用

大数据：把大任务拆分成小任务 

![image-20210323095027755](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323095027755.png)

> ForkJoin特点：工作窃取

维护的是双端队列

如：有2个线程A,B执行任务，B线程优先完成了队列中的任务后会去执行线程A队列中的任务

![image-20210323095852169](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323095852169.png)

![image-20210323100011302](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323100011302.png)





----



> ForkJoin

```java
package com.lrq.forkjoin;

import java.util.concurrent.RecursiveTask;

/**
 * 求和计算
 * 如何使用ForkJoin
 * 1、通过ForkJoinPool 来执行
 * 2、计算任务ForkJoinPool.execute(ForkJoinTask task)
 * 3、计算类要继承ForkJoinTask
 */
public class ForkJoinDemo extends RecursiveTask<Long> {
    private Long start;
    private Long end;

    //临界值
    private Long temp = 10000L;

    public ForkJoinDemo(Long start, Long end) {
        this.start = start;
        this.end = end;
    }

    protected Long compute() {
        if((end - start) < temp){
            Long sum = 0L;
            for (Long i = start; i <= end; i++) {
                sum += i ;
            }
            return sum;
        }else { //forkjoin 递归
            Long middle = (start + end) / 2;//中间值
            ForkJoinDemo task1 = new ForkJoinDemo(start,middle);
            task1.fork();//拆分任务，把任务压入线程队列
            ForkJoinDemo task2 = new ForkJoinDemo(middle+1,end);
            task2.fork();//拆分任务，把任务压入线程队列
            return task1.join()+task2.join();
        }
    }
}
```



测试

```java
package com.lrq.forkjoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.stream.LongStream;

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
//        test1();//9576
//        test2();//6363
        test3();//830
    }

    public static void test1(){
        Long start = System.currentTimeMillis();
        Long sum = 0L;
        for (Long i = 1L; i <= 10_0000_0000; i++) {
            sum += i ;
        }
        Long end = System.currentTimeMillis();
        System.out.println("sum="+sum+"时间："+(end-start));
    }

    public static void test2() throws ExecutionException, InterruptedException {
        Long start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinDemo task = new ForkJoinDemo(0L,10_0000_0000L);
//        forkJoinPool.execute(task);//提交任务 同步
        ForkJoinTask<Long> submit = forkJoinPool.submit(task);//提交任务 异步
        Long sum = submit.get();//会阻塞
        Long end = System.currentTimeMillis();
        System.out.println("sum="+sum+"时间："+(end-start));
    }

    public static void test3(){
        Long start = System.currentTimeMillis();
        //Stream 并行流
        long sum = LongStream.rangeClosed(0L, 10_0000_0000).parallel().reduce(0, Long::sum);
        Long end = System.currentTimeMillis();
        System.out.println("sum="+sum+"时间："+(end-start));
    }
}
```

## 14、异步回调

> Future 设计初衷，对将来的某个事件的结果进行建模

实现类常用：CompletableFuture<T>

```java
package com.lrq.future;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * 异步调用:CompletableFuture
 * 异步执行
 * 成功回调
 * 失败回调
 */
public class Demo01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //没有返回值的 runAsync 异步回调
//        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(()->{
//            try {
//                TimeUnit.SECONDS.sleep(2);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            System.out.println(Thread.currentThread().getName()+"runAsync=>Void");
//        });
//        System.out.println("1111");
//        completableFuture.get();//获取阻塞执行结果

        //有返回值得 supplyAsync 异步回调
        //成功和失败的回调
        //返回错误信息
        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread().getName()+"supplyAsync=>String");
            int i = 10/0;
            return "1024";
        });

        System.out.println(completableFuture.whenComplete((t, u) -> {
            System.out.println("t=>" + t);//正常的返回结果
            System.out.println("u=>" + u);//错误信息 java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
        }).exceptionally((e) -> {
            System.out.println(e.getMessage());
            return "123";//可以获取到错误的返回结果
        }).get());
    }
}
```



---

## 15、JMM

>Volatile

Volatile 是Java虚拟机提供轻量级的同步机制

1、保证可见性

2、==**不保证原子性**==

3、禁止指令重排



> 什么是 JMM

JMM Java内存模型，不存在的，概念，约定

**关于JMM的一些同步约定**：

1、线程解锁前，必须把共享变量立刻刷回主存

2、线程加锁前，必须读取主存中的最新值到工作内存中

3、加锁和解锁是同一把锁



线程  **主存** **工作内存**

**8种操作**

![image-20210323141510047](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323141510047.png)

![image-20210323141746560](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323141746560.png)

**JAVA内存模型的同步八种操作**

•Lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。

•Unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。

•Read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，便于后面的load动作使用。

•Load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。

•Use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。

•assign(（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量。

•Store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。

•Write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

**JAVA内存模型的同步规则**

•如果要把一个变量从主内存中复制到工作内存中，就需要顺序的执行read和load操作，如果把变量从工作内存同步到主内存中，就需要顺序的执行store和write操作。但Java内存模型只要求上述操作必须是按顺序执行，而没有要求是连续执行。

•不允许read和load、 store和write操作之一单独出现

•不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须同步到主内存中。

•不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中。

•一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即对一个变量实施use和store操作之前，必须先执行assign和load操作。

•一个变量在同一时刻只允许一条线程对其进行lock操作，但是lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。

•如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。

•如果一个变量事先没有被lock操作，则不允许对它执行unlock。也不允许unlock一个被其他线程锁定的变量。

•对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

---



## 16、Volatile



> 保证可见性

```java
package com.lrq.cvolatile;

import java.util.concurrent.TimeUnit;

public class JMMDemo {
    //不加 volatile 程序就会死循环
    //加  volatile 可以保证可见性
    private volatile static int num = 0;
    public static void main(String[] args) {
        new Thread(()->{//线程1 对主内存的变化不知道
            while (num == 0){

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        num = 1;
        System.out.println(num);
    }
}
```

> 不保证原子性

原子性：不可分割

线程A在执行任务的时候，不能被打扰，也不能被分割。要么同时成功，要么同时失败

```java
package com.lrq.cvolatile;


public class VDemo {
    //volatile不保证原子性
    private volatile static int num = 0;

    public static void add(){
        num++;
    }
    public static void main(String[] args) {

        for (int i = 0; i <= 20; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }
        while (Thread.activeCount()>2){ //main gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+" "+ num);
    }
}
```



**如果不加Lock和Synchronized，怎么保证原子性**

![image-20210323155127117](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323155127117.png)



使用原子类，解决原子性问题

![image-20210323155334344](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323155334344.png)

> 原子类

```java
package com.lrq.cvolatile;


import java.util.concurrent.atomic.AtomicInteger;

public class VDemo {
    //原子类
    private volatile static AtomicInteger num = new AtomicInteger();

    public static void add(){
//        num++;//不是原子性操作
        num.getAndIncrement();//AtomicInteger +1 方法，底层采用CAS
    }
    public static void main(String[] args) {

        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }
        while (Thread.activeCount()>2){ //main gc
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+" "+ num);
    }
}
```

这些类的底层都直接和操作系统挂钩，在内存中修改值，Unsafe类是一个很特殊的存在



> 指令重排

什么是指令重排：**你写的程序，计算机并不是按照写的那样去执行的**

==**处理器在进行指令重排的时候，考虑：数据之间的依赖性**==

数据可能造成影响

**Volatile可以避免指令重排：**

内存保障，CPU指令。作用：

1、保证特定的操作的执行顺序

2、可以保证某些变量的内存可见性（利用这些特性volatile实现了可见性）

![image-20210323171239577](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210323171239577.png)

**Volatile可以保持可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！**



## 17、单例模式

饿汉式，DCL懒汉式

> 饿汉式

```java
package com.lrq.single;

/**
 * 饿汉式单例
 */
public class Hungry {
    //可能会浪费空间
    private byte[] data1 = new byte[1024*1024];
    private byte[] data2 = new byte[1024*1024];
    private byte[] data3 = new byte[1024*1024];
    private byte[] data4 = new byte[1024*1024];
    public Hungry() {
    }
    private final static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance(){
        return HUNGRY;
    }
}
```

> DCL懒汉式

```java
package com.lrq.single;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

/**
 * 懒汉式单例
 */
public class LazyMan {

    private static boolean flag = false;

    public LazyMan() {
        synchronized (LazyMan.class) {
            if(!flag){
                flag = true;
            }else {
                throw new RuntimeException("不要试图使用反射破坏异常");
            }
        }
        System.out.println(Thread.currentThread().getName() + " OK");
    }
    private volatile static LazyMan lazyMan;

    //双重检测锁模式的 懒汉式单例 DCL懒汉式
    public static LazyMan getInstance(){
        if (lazyMan == null){
            synchronized (LazyMan.class){
                if(lazyMan == null){
                    lazyMan = new LazyMan();//不是原子性操作
                    /**
                     * 1、分配内存空间
                     * 2、执行构造方法，初始化对象
                     * 3、把这个对象指向内存空间
                     * 可能有指令重排问题
                     */
                }
            }
        }
        return lazyMan;
    }
    //反射
    public static void main(String[] args) throws Exception {
//        LazyMan instance = LazyMan.getInstance();
        Field flag = LazyMan.class.getDeclaredField("flag");
        flag.setAccessible(true);


        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        LazyMan instance = declaredConstructor.newInstance();
        flag.set(instance,false);
        LazyMan instance2 = declaredConstructor.newInstance();

        System.out.println(instance);
        System.out.println(instance2);
    }
}
```

> 静态内部类

```java
package com.lrq.single;

/**
 * 静态内部类
 */
public class Holder {

    public Holder() {

    }

    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }

    public static class InnerClass{
        private static final Holder HOLDER = new Holder();
    }
}
```

> 单例不安全，反射

```java
package com.lrq.single;

import java.lang.reflect.Constructor;

/**
 * 枚举也是一个class类
 */
public enum  EnumSingle {

    INSTANCE;

    public EnumSingle getInstance() {
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws Exception {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        Constructor<EnumSingle> declaredConstructor =                                                                   EnumSingle.class.getDeclaredConstructor(String.class, int.class);
        declaredConstructor.setAccessible(true);
        EnumSingle instance2 = declaredConstructor.newInstance();

        System.out.println(instance1);
        System.out.println(instance2);
    }
}
```



![image-20210327210650522](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210327210650522.png)

枚举类型的最终反编译

```java
// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   EnumSingle.java

package com.lrq.single;


public final class EnumSingle extends Enum
{

    public static EnumSingle[] values()
    {
        return (EnumSingle[])$VALUES.clone();
    }

    public static EnumSingle valueOf(String name)
    {
        return (EnumSingle)Enum.valueOf(com/lrq/single/EnumSingle, name);
    }

    private EnumSingle(String s, int i)
    {
        super(s, i);
    }

    public EnumSingle getInstance()
    {
        return INSTANCE;
    }

    public static final EnumSingle INSTANCE;
    private static final EnumSingle $VALUES[];

    static 
    {
        INSTANCE = new EnumSingle("INSTANCE", 0);
        $VALUES = (new EnumSingle[] {
            INSTANCE
        });
    }
}

```



## 18、深入理解CAS

> 什么是CAS

```java
package com.lrq.cas;

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo {
    //CAS compareAndSet：比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);//期望值

        //期望、更新
        //public final boolean compareAndSet(int expect, int update)
        //如果期望的值达到了，那么就更新，否则不更新,CAS 是CPU的并发原语！
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
        atomicInteger.getAndIncrement();

        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
```



> Unsafe类

![image-20210327214919824](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210327214919824.png)

![image-20210327221539349](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210327221539349.png)

![image-20210327221653247](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210327221653247.png)



CAS：比较当前工作内存的值和主内存的值，如果这个值是期望的值，那么执行操作！如果不是就一直循环！

**缺点**：

1. 循环会耗时
2. 一次性只能保证一个共享变量的原子性
3. ABA问题

---



> CAS ：ABA 问题

![image-20210328204727615](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328204727615.png)

```java
package com.lrq.cas;

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo {
    //CAS compareAndSet：比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);//期望值

        //期望、更新
        //public final boolean compareAndSet(int expect, int update)
        //如果期望的值达到了，那么就更新，否则不更新,CAS 是CPU的并发原语！
        //===========该线程将期望值修改后又改回==================ABA问题
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());
        //===========期望的线程==================ABA问题
        System.out.println(atomicInteger.compareAndSet(2020, 6666));
        System.out.println(atomicInteger.get());
    }
}
```

----

## 19、原子引用

> 解决ABA 问题，引入原子引用！对应的思想：乐观锁

带版本号的原子操作！

```java
package com.lrq.cas;

import java.util.concurrent.atomic.AtomicStampedReference;

public class CASDemo {
    //AtomicStampedReference 注意：如果泛型是一个包装类，注意对象的引用问题

    //正常业务操作，这里面比较的都是一个个对象
    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1,1);

    //CAS compareAndSet：比较并交换
    public static void main(String[] args) {
//        AtomicInteger atomicInteger = new AtomicInteger(2020);//期望值

        //乐观锁的原理相同
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();//获得版本号
            System.out.println("a1=>"+stamp);
            try {
                Thread.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            atomicStampedReference.compareAndSet(1, 2,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);

            System.out.println("a2=>"+atomicStampedReference.getStamp());

            System.out.println(atomicStampedReference.compareAndSet(2, 1,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));

            System.out.println("a3=>"+atomicStampedReference.getStamp());
        },"a").start();

        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();//获得版本号
            System.out.println("b1=>"+stamp);

            try {
                Thread.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(atomicStampedReference.compareAndSet(1, 6,
                    stamp, stamp + 1));

            System.out.println("b2=>"+atomicStampedReference.getStamp());
        },"b").start();
    }
}
```

**注意：**

**Integer 使用了对象缓存机制，默认范围是127至-128，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间；**

![image-20210328214314840](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328214314840.png)



---

## 20、各种锁的理解

### 1、公平锁、非公平锁

公平锁：非常公平，不能够插队，必须先来后到！

非公平锁：非常不公平，可以插队（默认都是非公平）

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

----



### 2、可重入锁

可重入锁（递归锁）

![image-20210328215731793](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328215731793.png)

> synchronized 可重入锁

```java
package com.lrq.lock;

/**
 * synchronized 可重入锁
 */
public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(()->{
            phone.sms();
        },"A").start();

        new Thread(()->{
            phone.sms();
        },"B").start();
    }
}

class Phone{
    public synchronized void sms(){
        System.out.println(Thread.currentThread().getName()+"sms");
        call();
    }

    public synchronized void call(){
        System.out.println(Thread.currentThread().getName()+"call");
    }
}

```

> Lock 可重入锁

```java
package com.lrq.lock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Lock 可重入锁
 */
public class Demo02 {
    public static void main(String[] args) {
        Phone2 phone = new Phone2();

        new Thread(()->{
            phone.sms();
        },"A").start();

        new Thread(()->{
            phone.sms();
        },"B").start();
    }
}

class Phone2{
    Lock lock = new ReentrantLock();
    public  void sms(){
        lock.lock();//细节问题：lock.lock();  lock.unlock();// lock 锁必须配对，否则就会死在里面

        try {
            System.out.println(Thread.currentThread().getName()+"sms");
            call();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    public  void call(){
        lock.lock();

        try {
            System.out.println(Thread.currentThread().getName()+"call");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



---

### 3、自旋锁

![image-20210328222037495](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328222037495.png)

```java
package com.lrq.lock;

import java.util.concurrent.atomic.AtomicReference;

/**
 * 自旋锁
 */
public class SpinlockDemo {
    //Thread 默认为 null
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "==> myLock");
        while (!atomicReference.compareAndSet(null, thread)) {

        }
    }

    public void myUnLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "==> myLock");
        atomicReference.compareAndSet(thread, null);
    }
}
```

> 测试

```java
package com.lrq.lock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TestSpinlock {
    public static void main(String[] args) throws InterruptedException {
//        ReentrantLock reentrantLock = new ReentrantLock();
//        reentrantLock.lock();
//        reentrantLock.unlock();

        SpinlockDemo lock = new SpinlockDemo();
        new Thread(()->{
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        },"T1").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(()->{
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        },"T2").start();



    }
}
```

### 4、死锁

> 死锁是什么



![image-20210328224508541](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328224508541.png)

死锁测试，怎么排除死锁：

```java
package com.lrq.lock;

import java.util.concurrent.TimeUnit;

public class DeadLockDemo {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new MyThread(lockA,lockB),"T1").start();
        new Thread(new MyThread(lockB,lockA),"T1").start();
    }
}

class MyThread implements Runnable{

    private String lockA;
    private String lockB;

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName() + "lock" + lockA + "=>get" + lockB);

            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + "lock" + lockB + "=>get" + lockA);
            }
        }
    }
}
```



> 解决问题

1、使用 ==jps -l==定位进程号

![image-20210328231311522](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328231311522.png)

2、使用 ==jstack 进程号== 找到死锁问题

![image-20210328231631925](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210328231631925.png)

查看堆栈信息





















